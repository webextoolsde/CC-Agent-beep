import { DataFetcherValueType } from "./DataFetcher";
import { QmServiceTypes } from "./QmPerformanceDataRequester";
export declare namespace AgentPerformanceTypes {
    namespace DataFetcherTypes {
        type DataFetcherCoreData = {
            [key in QmServiceTypes.CoreMetricColumn | QmServiceTypes.MetadataColumn]?: DataFetcherValueType;
        };
        const DATA_FETCHER_TEAM_PREFIX = "teamAvg";
        type DataFetcherTeamAvgData = {
            [key in TeamAvgColumn]?: DataFetcherValueType;
        };
        type DataFetcherChannelValue = {
            [K in QmServiceTypes.ChannelType]?: DataFetcherValueType;
        };
        type DetailedPerformanceDataObj = {
            total: DataFetcherValueType;
            inbound?: DataFetcherChannelValue;
            outbound?: DataFetcherChannelValue;
        };
        type DetailedCoreMetricData = {
            [key in QmServiceTypes.CoreMetricColumn]?: DetailedPerformanceDataObj;
        };
        type DetailedPerformanceData = {
            agentId: string;
            teamId: string;
            agentData: DetailedCoreMetricData;
            teamAvgData: DetailedCoreMetricData;
        };
        type AgentsDetailedPerformanceData = DetailedPerformanceData[];
        type AgentPerformanceData = DataFetcherCoreData & DataFetcherTeamAvgData;
        enum TeamAvgColumn {
            TeamAvgConnectedCount = "teamAvgConnectedCount",
            TeamAvgConnectedDurationMs = "teamAvgConnectedDurationMs",
            TeamAvgAverageHandleTimeMs = "teamAvgAverageHandleTimeMs",
            TeamAvgConsultRequestCount = "teamAvgConsultRequestCount",
            TeamAvgConsultRequestDurationMs = "teamAvgConsultRequestDurationMs",
            TeamAvgConsultRequestCountPerInteraction = "teamAvgConsultRequestCountPerInteraction",
            TeamAvgConsultAnswerCount = "teamAvgConsultAnswerCount",
            TeamAvgAverageConsultDuration = "teamAvgAverageConsultDuration",
            TeamAvgHoldCount = "teamAvgHoldCount",
            TeamAvgHoldDurationMs = "teamAvgHoldDurationMs",
            TeamAvgHoldCountPerCall = "teamAvgHoldCountPerCall",
            TeamAvgHoldDurationRatioMs = "teamAvgHoldDurationRatioMs",
            TeamAvgAverageHoldDuration = "teamAvgAverageHoldDuration",
            TeamAvgTransferCount = "teamAvgTransferCount",
            TeamAvgTransferCountPerInteraction = "teamAvgTransferCountPerInteraction",
            TeamAvgAverageWrapupDurationMs = "teamAvgAverageWrapupDurationMs",
            TeamAvgOccupancy = "teamAvgOccupancy",
            TeamAvgAverageEvaluationScore = "teamAvgAverageEvaluationScore",
            TeamAvgAutoCSAT = "teamAvgAutoCSAT",
            TeamAvgSentimentScore = "teamAvgSentimentScore",
            TeamAvgTimeBetweenChatReplies = "teamAvgTimeBetweenChatReplies",
            TeamAvgCrossTalk = "teamAvgCrossTalk",
            TeamAvgTalkRatio = "teamAvgTalkRatio",
            TeamAvgSilenceMonitor = "teamAvgSilenceMonitor",
            TeamAvgTotalLoggedInDuration = "teamAvgTotalLoggedInDuration"
        }
        const TEAM_AVG_TO_CORE_METRIC_MAP: Record<TeamAvgColumn, QmServiceTypes.CoreMetricColumn>;
        type AllColumnTypes = QmServiceTypes.MetadataColumn | QmServiceTypes.CoreMetricColumn | TeamAvgColumn;
        type ColumnValue = {
            [key: string]: ColumnValueType;
        };
        type ColumnValueType = DataFetcherValueType;
        type Row = {
            [columnName: string]: AgentPerformanceTypes.DataFetcherTypes.ColumnValueType;
        };
        type Table = Row[];
    }
    type Question = {
        id: string;
        text: string;
        tooltipText: string | null;
        questionType: QuestionType;
        options: Option[];
        weight: number;
        autoFailThreshold?: number;
        selectedAnswer?: string;
        comment?: string;
        aiSuggestedAnswer?: string;
        aiSuggestedAnswerJustification?: string;
        aiEvalDetails?: AIEvalDetails[];
    };
    interface TeamAssignmentsResponse {
        formId: string;
        team: {
            teamId: string;
        };
        creationTime: string;
    }
    interface QueueAssignmentsResponse {
        formId: string;
        queue: {
            queueId: string;
        };
        creationTime: string;
    }
    type Section = {
        id: string;
        name: string;
        questions: Question[];
        manualEvaluationRequired?: boolean;
    };
    type Interaction = {
        interactionId: string;
        startTime: number;
        agent: {
            userId: string;
            ccUserId: string;
            displayName: string;
        };
    };
    interface FormStats {
        formId: string;
        averageScore: number;
        numberOfEvaluations: number;
    }
    type Option = {
        id?: number;
        text: string;
        weight: number;
        autoFail: boolean;
    };
    type Answer = {
        id?: string;
        questionId: string;
        comment?: string;
        selectedOptions: {
            id: number;
            text: string;
            weight: number;
        }[];
    };
    type EvaluationDefinition = {
        id?: string;
        interaction: Interaction;
        status: EvaluationStatus;
        formId: string;
        createdAt: string;
        lastModifiedAt: string;
        answers: Answer[];
        lastModifiedBy?: {
            userId: string;
            ccUserId: string;
            displayName: string;
        };
        score?: number;
    };
    type AgentEvaluationDetails = {
        ccUserId: string;
        displayName: string;
    };
    type FormEvaluationFrequencies = {
        teamFrequency?: number;
        queueFrequency?: number;
    };
    type FormDefinition = {
        id: string;
        name: string;
        sections: Section[];
        status: string;
        description?: string;
    };
    type FormResponse = FormDefinition & {
        aiEvaluationFrequency: FormEvaluationFrequencies;
    };
    type AIAssistedEvaluationResponse = {
        interaction: {
            interactionId: string;
        };
        formId: string;
        suggestedAnswers: SuggestedAnswers[];
    };
    type SuggestedAnswers = {
        questionId: string;
        justification?: string;
        selectedOptions: AIEvalDetails[];
    };
    type AIEvalDetails = {
        id: number;
        text: string;
        weight: number;
        confidence?: number;
        detectionPoints?: AIDetectionPoint[];
    };
    type AIDetectionPoint = {
        startTimeMs: number;
        endTimeMs: number;
        text: string;
    };
    type FetchOrgFormsResponse = {
        data: FormDefinition[];
        meta?: {
            pageNumber: number;
            pageSize: number;
            totalRecords: number;
            totalPages: number;
        };
    };
    type AgentPerformanceInfo = {
        agentId: string;
        numberOfEvaluationInteractions: number;
        numberOfTranscriptAnalysisInteractions: number;
        averageEvaluationScore?: number;
    };
    type FetchAgentPerformanceScoresResponse = {
        agentPerformanceInfos: AgentPerformanceInfo[];
    };
    enum EvaluationMode {
        VIEW = "VIEW",
        EDIT = "EDIT",
        CREATE = "CREATE"
    }
    enum EvaluationStatus {
        ARCHIVED = "ARCHIVED",
        DRAFT = "DRAFT",
        ACTIVE = "ACTIVE",
        PUBLISHED = "PUBLISHED"
    }
    enum EvaluationMetricEvents {
        VIEWING_PUBLISHED_EVALUATION = "viewing-published-evaluation",
        RETRIEVE_EVALUATION_FORMS = "retrieve-evaluation-forms",
        RETRIEVE_EVALUATION_FORM = "retrieve-evaluation-form",
        RETRIEVE_EVALUATION = "retrieve-evaluation",
        SAVE_EVALUATION = "save-evaluation",
        PUBLISH_EVALUATION = "publish-evaluation",
        DISCARD_EVALUATION = "discard-evaluation",
        CREATE_EVALUATION = "create-evaluation",
        AI_ASSIST_SUGGESTIONS_UNAVAILABLE = "ai-assist-suggestions-unavailable",
        ERROR_RETRIEVING_AI_ASSIST_SUGGESTIONS = "error-retrieving-ai-assist-suggestions",
        AI_ASSIST_POLLING_MAX_RETRIES = "ai-assist-polling-max-retries",
        AI_ASSIST_POLLING_SUCCESS = "ai-assist-polling-success",
        AI_ASSIST_POLLING_FAILED = "ai-assist-polling-failed"
    }
    enum QuestionType {
        YES_NO = "YES_NO",
        SCALE = "SCALE"
    }
}
