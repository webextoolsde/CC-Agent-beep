import { FairUsage, RateLimitInfo } from "../../utils/fairUsage";
import { PrometheusService } from "../prometheus/prometheus-tracking";
import { WebexMetricsService } from "../webexMetrics/webex-metrics-service";
import { CACHE_KEYS, EVENT_CONSTANTS, PROPS_CONSTANTS } from "./constants";
export declare const SERVICE_PROVIDERS: {
    prometheus: string;
    webex_behavioral: string;
    webex_operational: string;
    webex_business: string;
};
export declare const DEFAULT_RATE_LIMITS: RateLimitInfo[];
export declare const defaultFairUsageBuilder: (rateLimits?: RateLimitInfo[]) => FairUsage;
export declare class TelemetryService {
    TELEM_EVENT: typeof EVENT_CONSTANTS;
    TELEM_PROPS: typeof PROPS_CONSTANTS;
    TELEM_CACHE_KEYS: typeof CACHE_KEYS;
    SERVICE_PROVIDERS: {
        prometheus: string;
        webex_behavioral: string;
        webex_operational: string;
        webex_business: string;
    };
    private initialized;
    private webexMetrics;
    private prometheus;
    private readonly fairUsage;
    private rateLimitCheckTimer?;
    private queuedMetrics;
    constructor(fairUsageBuilder?: () => FairUsage);
    private startRateLimitChecking;
    init(webexMetrics: WebexMetricsService, prometheus: PrometheusService): TelemetryService;
    private readonly callbackEventRegister;
    registerCallbackEvent(name: string, callback: (options: any) => void): void;
    track(name: string, options?: any, services?: string[]): void;
    timeEvent(name: string, services?: string[]): void;
    register(superProps: Record<string, any>): void;
    setValueInCache(key: string, value: string | number | boolean): void;
    getValueFromCache(key: string): any;
    removeValueFromCache(key: string): void;
    private trackBehaviouralEvent;
    private sendQueuedMetrics;
}
